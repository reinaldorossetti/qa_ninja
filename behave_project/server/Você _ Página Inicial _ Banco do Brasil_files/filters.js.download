'use strict';

/* Filters */
define(['angular', 'factories', 'helpers'], function (angular) {
  	angular.module('bb.filters', [])
  	.filter('mes3', function() {
		return function(input) {
			if(typeof input === 'undefined' ||  input == null) return;
			var mesExtenso = {
                "01" : "Jan",
                "02" : "Fev",
                "03" : "Mar",
                "04" : "Abr",
                "05" : "Mai",
                "06" : "Jun",
                "07" : "Jul",
                "08" : "Ago",
                "09" : "Set",
                "10" : "Out",
                "11" : "Nov",
                "12" : "Dez"
            }
            return mesExtenso[input];
		};
	})
	.filter('trust', [
	    '$sce',
	    function($sce) {
	      return function(value, type) {
	        // Defaults to treating trusted text as `html`
	        return $sce.trustAs(type || 'html', value);
	      }
	    }
	])
	.filter('getTexto', function() {
		return function(input) {
			// input = input+"";
			
			// if(typeof input === 'undefined' ||  input == '' ||  input == 'undefined' || input == 'false') return '';
			if(typeof input !== 'string') return '';
			
			if(input.indexOf("&gt;&gt;") != -1 || input.indexOf(">>") != -1) {
				var textoSplit = input.split(/>>|&gt;&gt;/);;
                var txt = textoSplit[0];
                // var txtLink = textoSplit[1];

            	return txt;
            }
          
            
            return input;
		};
	})
	.filter('getValorCMA', function() {
		return function(arrayValores, campoChave) {
			var retorno = "";
			
			if(typeof arrayValores == "undefined")
				return retorno;
			
			arrayValores.forEach(function(dado){
				
				if(Object.keys(dado) == campoChave){
					retorno =  dado[Object.keys(dado)];
				}
			});
			
			return retorno;
			
		};
	})
	
	    
    .filter('isSinal', function() {
		return function(input,sinal) {
			if(typeof input != 'string') return '';

			if(input.indexOf(sinal) != -1){
				return true;
			}else{
				return false;				
			}
						
		};
	})

	.filter('isEmpty', function() {
		return function(obj) {
			if(typeof obj === 'undefined') {
				return true;
			}else{
				if(typeof obj === 'string') {
					if(obj == ''){
						return true;
					}else{
						return false;
					} 
				}else{
					return false;	
				}
				return false;
			} 
									
		};
	})
	
	.filter('testeUrlInterna', function() {
		return function(input) {
			// input = input+"";			
			// if(typeof input === 'undefined' ||  input == '' ||  input == 'undefined' || input == 'false') return '';
			if(typeof input !== 'string') return '';
			var urlInterna = "/pbb/";
            if(input.indexOf("pbb/") != -1) {            		
            	var textoSplit = input.split('pbb/');
                var txt = urlInterna+textoSplit[1];                

            	return txt;
            }
            return input;
		};
	})
	.filter('getTextoLink', function() {
		return function(input) {
			// console.log("input", input);
			// input = input+"";
			
			// if(typeof input === 'undefined' ||  input == '' ||  input == 'undefined' || input == 'false') return ''; 
			if(typeof input !== 'string') return '';
            
			// if(input.indexOf(">>") != -1) {
   //              var textoSplit = input.split('>>');
   //              var txt = textoSplit[0];
   //              var txtLink = textoSplit[1];
   //              // console.log("txtLink2", txtLink.trim());
   //          	return txtLink.trim();
   //          }
            if(input.indexOf("&gt;&gt;") != -1 || input.indexOf(">>") != -1) {
                var textoSplit = input.split(/>>|&gt;&gt;/);
                // var txt = textoSplit[0];
                var txtLink = textoSplit[textoSplit.length -1];

            	return txtLink.trim();
            }
            return false;
		};
	})
	
	.filter('getTratamentoHashTagNG', function() {
		return function(input) {
			
			if(typeof input !== 'string') return '';
			
			if(input.indexOf("#ng") != -1) {
	            var txtLink = input.slice(0, input.indexOf("#ng"));
	          	return txtLink;
			 }
			return input;
		};
	})
	
	.filter('getSplit', function() {
		return function(input, split, pos) {
			if(typeof input !== 'string') return '';
            if(input.indexOf(split) != -1) {
                var textoSplit = input.split(split);
                if(pos >= 2) return textoSplit; 
                else if(pos >= 0) return textoSplit[pos];
            }
            if(pos >= 2) return false;
            else return input;
		};
	})
	.filter('getSplit2', function() {
		return function(input, token, orientacao) {
			if(typeof input !== 'string') return '';
			
            if(input.indexOf(token) != -1) {
            	
            	var textoSplit = input.split(token);
            	
            	if(orientacao == "left"){
            		return	textoSplit[0];
            	}else{
            		return	textoSplit[1];
            	}
            }else{
            	return input;
            } 
		};
	})
	.filter('getSplit3', function() {
		return function(input, token, orientacao) {
			if(typeof input !== 'string') return '';
			
            if(input.indexOf(token) != -1) {
            	
            	var textoSplit = input.split(token);
            	
            	if(orientacao == "titulo"){
            		return	textoSplit[0];
            	}if(orientacao == "descricao"){
            		return	textoSplit[1];
            	}if(orientacao == "imagem"){
            		return	textoSplit[2];
            	}
            }else{
            	return input;
            } 
		};
	})
	.filter('getTextoLinkInvertido', function() {
		return function(input) {
			
			if(typeof input !== 'string') return '';
			
    		if(input.indexOf(">>") != -1) {
                var textoSplit = input.split('>>');
                var txt = textoSplit[0];
                var txtLink = textoSplit[1];
            	return txt.trim();
            }else{
            	 return input;
            }
            return false;
		};
	})
	.filter('negrito', function() {
		return function(input) {
			// input = input+"";
			// if(typeof input === 'undefined' ||  input == '' ||  input == 'undefined' || input == 'false') return '';
			// if(typeof input !== 'string' || input == 'false') return '';
			if(typeof input !== 'string') return '';

			var linkInit = input.indexOf("$$");
			var linkEnd = input.lastIndexOf("$$");
			if(linkInit != -1 && linkEnd != -1) {
				var textoIniLink = input.substring(0,linkInit);
				linkInit = linkInit + 2;
				linkEnd = linkEnd;
				var textoMeioLink = input.substring(linkInit, linkEnd);
				linkEnd = linkEnd + 2;
				var textoFimLink = input.substring(linkEnd, input.length);
				var textoTratadoLink = textoIniLink+"<strong>"+textoMeioLink+"</strong>"+textoFimLink;
				return textoTratadoLink;
			}
			return input;

		};
	})
	.filter('negrito2', function() {
		return function(input) {
			if(typeof input !== 'string') return '';

			var linkInit = input.indexOf("$$");
			var linkEnd = input.lastIndexOf("$$");
			if(linkInit != -1 && linkEnd != -1) {
				var textoIniLink = input.substring(0,linkInit);
				linkInit = linkInit + 2;
				linkEnd = linkEnd;
				var textoMeioLink = input.substring(linkInit, linkEnd);
				linkEnd = linkEnd + 2;
				var textoFimLink = input.substring(linkEnd, input.length);
				var textoTratadoLink = "<span class='nrm' >"+textoIniLink+"</span> <strong>"+textoMeioLink+"</strong> <span class='nrm'>"+textoFimLink+"</span>";
				return textoTratadoLink;
			}
			return input;

		};
	})
	.filter('negritoResultado', function() {
		return function(input , termo) {
			if(typeof input !== 'string') return '';
			return input.replace(termo.toLowerCase(),"<span>"+termo+"</span>");

		};
	})
	.filter('youtubeID', function() {
		return function(url, returnBoolean) { 
			url = url.trim();
			if(typeof url !== 'string' ||  url == '') return false;
			if(typeof returnBoolean != true) returnBoolean = false;

			if (url.length <= 11) return returnBoolean ? true : url;
		    var regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
		    var match = url.match(regExp);
		    var matchID = "";
		    try {matchID = match[7].trim() } catch(exc){}
		    if(match&&matchID.length==11) {
		    	return returnBoolean ? true : matchID;
		    } else {
		    	return returnBoolean ? false : url;
		    }
		    // return (match&&matchID.length==11) ? matchID : url;

		};
	})
	.filter('youtubeEmbed', function($sce) {
		//rel=0&amp;controls=0&amp;showinfo=0
		return function(url, rel, controls, showinfo, autoplay) { 
			if(typeof url !== 'string' ||  url == '') return;
			if(typeof rel === 'undefined') rel = 0;
			if(typeof controls === 'undefined') controls = 1;
			if(typeof showinfo === 'undefined') showinfo = 1;
			if(typeof autoplay === 'undefined') autoplay = 0;
			url = url.trim();
		    var uri = "http://www.youtube.com/embed/";
			if (url.length <= 11) {
				uri += url;
			} else {
			    var regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
			    var match = url.match(regExp);
			    var matchID = "";
			    try {matchID = match[7].trim() } catch(exc){}
			    uri += (match&&matchID.length==11) ? matchID : url;
			}
			var urlParams = "?rel="+rel+"&amp;controls="+controls+"&amp;showinfo="+showinfo+"&amp;autoplay="+autoplay;
		    return $sce.trustAsResourceUrl(uri+urlParams);
		};
	})
	
	.filter('paginacao', function() {
		  return function(input, paginaAtual, quantidade) {
		   if(!input){return false;}
		    var start, end;
		    if (paginaAtual == 1) {
		        start = paginaAtual - 1;
		        end = start + quantidade;
		    } else {
		        start = (paginaAtual - 1) * quantidade;
		        end = start + quantidade;
		    }

		      
		    return input.slice(start, end);
		  };
	})

	.filter('cut', function () {
		// usage: {{some_text | cut:true:100:' ...'}}
        return function (value, wordwise, max, tail) {
            if (!value) return '';

            max = parseInt(max, 10);
            if (!max) return value;
            if (value.length <= max) return value;

            value = value.substr(0, max);
            if (wordwise) {
                var lastspace = value.lastIndexOf(' ');
                if (lastspace != -1) {
                    value = value.substr(0, lastspace);
                }
            }

            return value + (tail || '…');
        };
    })

    .filter('pcut', function () {
		// usage: {{some_text | cut:true:' ...'}}
        return function (value, limit, tail) {
        	if (!value || !limit) return '';
        	//var limit = 255;
        	
        	value = value.replace(/<[^>]*>/g, '');
        	value = value.length > limit ? value.substring(0, (limit+1))+"..." : value;

            return value;
        };
    })
    
	.filter('tagsClass', function () {
        return function (arrayTags, prefix) {
        	if(typeof arrayTags !== 'object') return;
        	if(typeof prefix !== 'string') prefix = "";
			var tagsClass = {};
			for (var i = 0; i < arrayTags.length; i++) {
				var nomeClass = prefix+arrayTags[i].nomeTag;
				nomeClass = nomeClass.toLowerCase();
				tagsClass[nomeClass] = true;
			};
			return tagsClass;
        };
    })

	.filter('hasTag', function () {
        return function (arrayTags, arrayHas) {
        	if(typeof arrayTags !== 'object') return;
        	if(typeof arrayHas !== 'object') arrayHas = ['desktop', 'tablet', 'smartphone'];
			for (var i = 0; i < arrayTags.length; i++) {
				var nomeTag = arrayTags[i].nomeTag.toLowerCase();
				if(arrayHas.indexOf(nomeTag) != -1) return true;
			};
			return false;
        };
    })

	.filter('dataPadrao', function () {
        return function (timestamp) {

        	var today = new Date(timestamp);
        	var dd = today.getDate();
        	var mm = today.getMonth()+1; //January is 0!
        	var yyyy = today.getFullYear();

        	if(dd<10) {
        	    dd='0'+dd
        	} 

        	if(mm<10) {
        	    mm='0'+mm
        	} 

        	today = dd+'/'+mm+'/'+yyyy;
        	// document.write(today);
        	return today;
        };
    })
    .filter('tituloPapeis', function () {
        return function (simbol) {

			  var tituloPapel = "";
		 
			  switch (simbol) {
	  	    	case 'IBOV':
	  	    		tituloPapel = "Ibovespa";
					break;
				case 'MERVAL25':
					tituloPapel = "Merval";
					break;
				case 'CCO':
					tituloPapel = "Nasdaq";
					break;
				case 'DJI':
					tituloPapel = "Dow Jones";
					break;
				case 'UKX':
					tituloPapel = "FTS-SE 100"
					break;
				case 'IME':
					tituloPapel = "IPC";
					break;
				case 'INJN&GB':
					tituloPapel = "Nikkei";
					break;
					
				case 'BBAS3':
	  	    		tituloPapel = "BRASIL ON";
					break;
				case 'GGBR4':
					tituloPapel = "GERDAU";
					break;
				case 'PETR4':
					tituloPapel = "PETROBRAS";
					break;
				case 'OIBR4':
					tituloPapel = "OI PN";
					break;
				case 'USIM5':
					tituloPapel = "USIMINAS"
					break;
				case 'VALE5':
					tituloPapel = "VALE PNA";
					break;
				case 'VIVT4':
					tituloPapel = "TELEF BRASILPN ";
					break;
					
					
					//cotacoes Cambio 1
				case 'BCEUR RS':
	  	    		tituloPapel = "Euro x Real";
					break;
				case 'BCEUR':
	  	    		tituloPapel = "Euro x Real";
	  	    		break;
				case 'PTAX850':
					tituloPapel = "US$ Comercial (V)";
					break;
				case 'CDI OVER':
					tituloPapel = "CDI (over)";
					break;
				case 'OZ1D':
					tituloPapel = "Ouro 250 Gramas Spot";
					break;
				case 'PTAX800':
					tituloPapel = "US$ Comercial (C)"
					break;
				case 'POUP DIA':
					tituloPapel = "Poupança Dia";
					break;
				case 'IGPM MES':
					tituloPapel = "IGP-M";
					break;
						

					
				default:
					tituloPapel = simbol;
					break;
			}
	
			return tituloPapel;
        };
    })
    
    .filter('dataPadrao_yy', function () {
        return function (timestamp) {

        	var today = new Date(timestamp);
        	var dd = today.getDate();
        	var mm = today.getMonth()+1; //January is 0!
        	var yy = String( today.getFullYear() ).substring(2);

        	if(dd<10) {
        	    dd='0'+dd
        	} 

        	if(mm<10) {
        	    mm='0'+mm
        	} 

        	today = dd+'/'+mm+'/'+yy;
        	// document.write(today);
        	return today;
        };
    })

	.filter('range', function(){
		return function(n) {
			var res = [];
			for (var i = 0; i < n; i++) res.push(i);
			return res;
		}
	})
  	
  	.filter('normalize', function(){
		return function(strAccents) {
			var strAccents = strAccents.split('');
			var strAccentsOut = new Array();
			var strAccentsLen = strAccents.length;
			var accents = 'ÀÁÂÃÄÅàáâãäåÒÓÔÕÕÖØòóôõöøÈÉÊËèéêëðÇçÐÌÍÎÏìíîïÙÚÛÜùúûüÑñŠšŸÿýŽž';
			var accentsOut = "AAAAAAaaaaaaOOOOOOOooooooEEEEeeeeeCcDIIIIiiiiUUUUuuuuNnSsYyyZz";
			for (var y = 0; y < strAccentsLen; y++) {
				if (accents.indexOf(strAccents[y]) != -1) {
					strAccentsOut[y] = accentsOut.substr(accents.indexOf(strAccents[y]), 1);
				} else
					strAccentsOut[y] = strAccents[y];
			}
			strAccentsOut = strAccentsOut.join('');
			return strAccentsOut;
		}
	})
        
        /*
	 * Filtro para obter as chamadas para compor o visualização do Call to Action.
	 * A escolha dos 2 itens é embasada em uma prioridade calculada a partir 
	 * das tags da chamada.
	 * @returns {Function}
	 */
	.filter('bbFilterCallToAction', function() {
		
		return function(chamadas) {
			
			var chamadaPosicao1 = null;
			var chamadaPosicao2 = null;
			
			function calculaPeso(posicao, chamada) {
				if (!chamada.posicao) {
					return chamada.modificadorPeso ? chamada.modificadorPeso+2 : 2;
				} else if (chamada.posicao == posicao) {
					return chamada.modificadorPeso ? chamada.modificadorPeso+1 : 1;
				} else {
					return null;
				}
			}
			
			angular.forEach(chamadas, function(c) {
				
				angular.forEach(c.tags, function(t) {
					var nome = t.nomeTag.toLowerCase();
					if ('desktop' === nome || 'tablet' === nome || 'smartphone' === nome) {
						c.modificadorPeso = -0.1;
					} else if (nome.indexOf('tag posiÃ§Ã£o') === 0) { //a
						c.posicao = new Number(nome.replace(/[^\d]+0?(\d+)/, '$1'));
					}
				});
				
				if (!c.posicao || c.posicao == 1) {
					
					var pesoPosicaoCorrente = chamadaPosicao1 ? calculaPeso(1, chamadaPosicao1) : null;
					
					if(!pesoPosicaoCorrente || pesoPosicaoCorrente > calculaPeso(1, c)) {
						
						pesoPosicaoCorrente = chamadaPosicao1 ? calculaPeso(2, chamadaPosicao1) : null;
						if(pesoPosicaoCorrente && (!chamadaPosicao2 || pesoPosicaoCorrente < calculaPeso(2, chamadaPosicao2)) ) {
							chamadaPosicao2 = chamadaPosicao1;
						}
						
						chamadaPosicao1 = c;
					}
				}
				
				if (chamadaPosicao1 != c && (!c.posicao || c.posicao == 2) ) {
					var pesoPosicaoCorrente = chamadaPosicao2 ? calculaPeso(2, chamadaPosicao2) : null;
					if(!pesoPosicaoCorrente || pesoPosicaoCorrente > calculaPeso(2, c)) {
						chamadaPosicao2 = c;
					}
				}
			});
			
			var retorno = [];
			
			if (chamadaPosicao1) {
				retorno.push(chamadaPosicao1);
			}
			
			if (chamadaPosicao2) {
				retorno.push(chamadaPosicao2);
			}
			
			return retorno;
		};
	})
	
	/*
	 * Filtro para restringir apenas chamadas que possuam tags condizentes com
	 * o dispositivo usado (desktop, tablet ou smartphone).
	 * O dispositivo é detectado no carregamento do filtro através do tamanho
	 * da tela.
	 * Caso não hajam tags de tipo de dispositivo, a chamada será inclusa.
	 * @returns {Function}
	 */
	.filter('bbFilterChamadasPorTamanhoTela', function() {
		return function(chamadas) {
			var w = (typeof window.innerWidth === "undefined") ? document.documentElement.offsetWidth : window.innerWidth;
			
			var tipos = {
				desktop: function() { return w > 768; },
				tablet: function() { return w <= 768 && w >= 667; },
				smartphone: function() { return w < 667; }
			};
			
			var novasChamadas = [];
			angular.forEach(chamadas, function(c){
				if(!c.tags || !c.tags.length) {
					novasChamadas.push(c);
				} else {
					var verificacao = null;
					var deveIncluir = false;
					
					angular.forEach(c.tags, function(t){
						verificacao = tipos[t.nomeTag.toLowerCase()] || verificacao;						
						if(verificacao) {
							deveIncluir = deveIncluir || verificacao();
						}
					});
					
					if(!verificacao || deveIncluir) {
						novasChamadas.push(c);
					}
				}
			});
			
			return novasChamadas;
		};
	})
  	
  	/*
	 * Filtro para restringir apenas chamadas que possuam tags condizentes com
	 * o dispositivo usado (desktop, tablet ou smartphone).
	 * O dispositivo é detectado no carregamento do filtro através do userAgent
	 * Caso não hajam tags de tipo de dispositivo, a chamada será inclusa.
	 * @returns {Function}
	 */
	.filter('bbFilterChamadasPorDispositivo', function() {
		return function(chamadas) {
			
			var w = (typeof window.innerWidth === "undefined") ? document.documentElement.offsetWidth : window.innerWidth;
			var ua = navigator.userAgent;
			var device = null;
			
			if (/iPad/i.test(ua)){
				device = "tablet";
			}else if(/Android/i.test(ua) && w > 667){
				device = "tablet";
			}else if (/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(ua)){
				device = "smartphone";
			} else{
				device = "desktop";
			}
			
			var novasChamadas = [];
			
			angular.forEach(chamadas, function(c,key){
				
				chamadas[key]["dispositivo"] = "";
				chamadas[key]["posicao"] = "";
				
				var tags = chamadas[key].tags;
				
				angular.forEach(tags, function(t){
					var descTag = t.nomeTag;
					if (descTag == "smartphone" || descTag == "tablet" || descTag == "desktop"){
						chamadas[key]["dispositivo"] = descTag;
					} else {
						chamadas[key]["posicao"] = parseInt(descTag.substr(descTag.length-2, descTag.length), 10);
					};
					
					if (c.posicao == ""){
						chamadas[key]["posicao"] = 99;
					}
					
					if (c.dispositivo == device){
						novasChamadas.push(c);
					} 
					
				})
				
			});
			
			
			return novasChamadas;
		};
	})
	
	/*
	* Filtro para converter [TEXTO](link) em <a href="LINK">TEXTO</a> no contexto de uma string
	* Baseado no showdownjs
	* https://github.com/showdownjs/showdown/blob/master/src/subParsers/anchors.js
	*/
	.filter('anchors', function () {
		return function (input) {
			var writeAnchorTag = function (wholeMatch, m1, m2, m3, m4) {
   			var linkText = m2,
        		url = m4;

        var result = '<a href="' + url + '">' + linkText + '</a>';
        
		    return result;
		  };

		  if (typeof input != "undefined") {
				var output = input.replace(/(\[((?:\[[^\]]*]|[^\[\]])*)]\([ \t]*()<?(.*?(?:\(.*?\).*?)?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeAnchorTag);
		  } else {
		  	return;
		  }
			
			return output;
		};
	})
	
  	/*
	 * Filtro para classes css que correspondem a fronteiras especificas 
	 * conforme tag de controle 
	 * @returns {Function}
	 */
	.filter('bbFilterClassResponsive', function() {
		
		return function(chamada) {
			var strClassResposivit = "";
			if(	typeof chamada != "undefined" && chamada != null && chamada.tags != null ){
				angular.forEach(chamada.tags, function(t) {
					var nome = t.nomeTag.trim().toLowerCase();
					
					if ('desktop' == nome || 'tablet' == nome || 'smartphone' == nome) {
				
						if ('desktop' == nome){
							strClassResposivit += 'isDesktop ';
						}
						if ('tablet' == nome ){
							strClassResposivit += 'isTablet ';
						}
						if ('smartphone' == nome){
							strClassResposivit += 'isSmartphone ';
						}
							
					} else { //a
						strClassResposivit = 'isDesktop isTablet isSmartphone';
					}
				});
			}
			
			return strClassResposivit;
		};
	})
	
	
	
	
  	/*
	 * Filtro para obter as chamadas para compor o visualização do Call to Action.
	 * A escolha dos 2 itens é embasada em uma prioridade calculada a partir 
	 * das tags da chamada.
	 * @returns {Function}
	 */
	.filter('bbFilterCallToAction', function() {
		
		return function(chamadas) {
			
			var chamadaPosicao1 = null;
			var chamadaPosicao2 = null;
			
			function calculaPeso(posicao, chamada) {
				if (!chamada.posicao) {
					return chamada.modificadorPeso ? chamada.modificadorPeso+2 : 2;
				} else if (chamada.posicao == posicao) {
					return chamada.modificadorPeso ? chamada.modificadorPeso+1 : 1;
				} else {
					return null;
				}
			}
			
			angular.forEach(chamadas, function(c) {
				
				angular.forEach(c.tags, function(t) {
					var nome = t.nomeTag.toLowerCase();
					if ('desktop' === nome || 'tablet' === nome || 'smartphone' === nome) {
						c.modificadorPeso = -0.1;
					} else if (nome.indexOf('tag posição') === 0) { //a
						c.posicao = new Number(nome.replace(/[^\d]+0?(\d+)/, '$1'));
					}
				});
				
				if (!c.posicao || c.posicao == 1) {
					
					var pesoPosicaoCorrente = chamadaPosicao1 ? calculaPeso(1, chamadaPosicao1) : null;
					
					if(!pesoPosicaoCorrente || pesoPosicaoCorrente > calculaPeso(1, c)) {
						
						pesoPosicaoCorrente = chamadaPosicao1 ? calculaPeso(2, chamadaPosicao1) : null;
						if(pesoPosicaoCorrente && (!chamadaPosicao2 || pesoPosicaoCorrente < calculaPeso(2, chamadaPosicao2)) ) {
							chamadaPosicao2 = chamadaPosicao1;
						}
						
						chamadaPosicao1 = c;
					}
				}
				
				if (chamadaPosicao1 != c && (!c.posicao || c.posicao == 2) ) {
					var pesoPosicaoCorrente = chamadaPosicao2 ? calculaPeso(2, chamadaPosicao2) : null;
					if(!pesoPosicaoCorrente || pesoPosicaoCorrente > calculaPeso(2, c)) {
						chamadaPosicao2 = c;
					}
				}
			});
			
			var retorno = [];
			
			if (chamadaPosicao1) {
				retorno.push(chamadaPosicao1);
			}
			
			if (chamadaPosicao2) {
				retorno.push(chamadaPosicao2);
			}
			
			return retorno;
		};
	})
	
	/*
	 * Filtro para restringir apenas chamadas que possuam tags condizentes com
	 * o dispositivo usado (desktop, tablet ou smartphone).
	 * O dispositivo é detectado no carregamento do filtro através do tamanho
	 * da tela.
	 * Caso não hajam tags de tipo de dispositivo, a chamada será inclusa.
	 * @returns {Function}
	 */
	.filter('bbFilterChamadasPorTamanhoTela', function() {
		return function(chamadas) {
			var w = (typeof window.innerWidth === "undefined") ? document.documentElement.offsetWidth : window.innerWidth;
			
			var tipos = {
				desktop: function() { return w > 768; },
				tablet: function() { return w <= 768 && w >= 667; },
				smartphone: function() { return w < 667; }
			};
			
			var novasChamadas = [];
			angular.forEach(chamadas, function(c){
				if(!c.tags || !c.tags.length) {
					novasChamadas.push(c);
				} else {
					var verificacao = null;
					var deveIncluir = false;
					
					angular.forEach(c.tags, function(t){
						verificacao = tipos[t.nomeTag.toLowerCase()] || verificacao;
						if(verificacao) {
							deveIncluir = deveIncluir || verificacao();
						}
					});
					
					if(!verificacao || deveIncluir) {
						novasChamadas.push(c);
					}
				}
			});
			
			return novasChamadas;
		};
	});
	
});